---
title: "openNCAreport Basic Walkthrough"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{basic_walkthrough}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Load package

```{r setup}
library(openNCAreport)
```

## Set input parameters

The walk-through below has a set of input parameters which will be unique to each analysis:

- `profile` - the parameter name in the PK Parameter data which corresponds to an identifier of one experimental unit of analysis
- `tc_path` - the path string to the input data
- `flag` - the parameter name in the PK Parameter data which corresponds to summary grouping parameter
- `by` - the parameter name in the PK Parameter data which corresponds to summary grouping parameter


```{r params}
profile <- "SDEID"
# This is an example test-case built into the package.
tc_path <- system.file("test_data", package = "openNCAreport")
flag <- "FLGACCEPTKEL"
by <- "TREATXT"
```

## Loading a test case

Loading a test case works in one of two ways, either the user specifies a path to a
directory containing a collection of four requisite CSV data sets: 

- The Model Configuration Template (MTC)
- The Analysis Ready Dataset (ARD) 
- The Flags data set (FLG) 
- The PK Parameters data set (PARAM) 

Each identified with the patterns:  "ARD", "MCT", "FLG, and "PARAM" in the
file names. Or the user has the options to include paths to each file. In this 
case we are using the built-in example data.

```{r loadtc}

tc <- load_test_case(tc_path)

# Get the WDS
get_wds(tc)
```

Alternatively, there's a more rudimentary function, `make_test_case()` which takes the separate `data.frame`s as the arguments; which may be useful in interactive use.


## Assigning parameter labels

The next step is to assign labels for better quality output in {gtsummary}. This can be done by modifying the `label` attribute of the variables in the data. This keeps the parameter names immutable while leaving room for customization.

Appropriate labels are deterministic given a specific analysis, and can be derived from the MCT with help from a data-structure called `nca_dependency_list`, which stores the parameter-label-unit_class correspondence. Using `assign_wds_labels()` on the test case object will automatically assign the appropriate labels from the MCT and `nca_dependency_list`.

The `nca_dependency_list` is a list with 204 slots, one per parameter, each slot has a further 8 nested slots

- parameter label - The paramter label for presentation
- cdisc_label - 
- regex - A RegEx pattern that links vars in the parameter data to their slot here
- valid_models - 
- display_list_models - 
- predecessors - 

The `nca_dependency_list` is not explicitly exported from the package, but is available to users with `openNCAreport:::nca_dependency_list`, and the code used to generate the list is built into the package and can be found at:

```{r, eval=FALSE}
dir <-system.file("ext_code", "nca_depedency_list.R", package = "openNCAreport")
file.edit(dir)
```

For more advanced users, you may use the code above to make updates to the dependency list, and then it's possible to build the new version back into the pacakge via:

```{r, eval = FALSE}
# object must have the name "nca_dependency_list", and be set to internal and
# overwrite
usethis::use_data(nca_dependency_list, internal = TRUE, overwrite = TRUE)

```

```{r labels}
# What is the unit class of TMAX? This value can be used to locate the
# appropriate unit in the MCT
openNCAreport:::nca_dependency_list[["TMAX"]]$unit_class

tc <- tc %>% 
      assign_wds_labels()


# Check a label
attr(tc$WDS$THALF, which = "label")
```

Manual adjustment of a label can be achieved via:`tc$WDS$par <- update_label(tc$WDS$par, "new label")`. Where `tc` is the `openNCA_testcase` and `par` is the parameter name.

## Filter exclusions

Filtering out exclusions is one of the simple study-design use-cases that is currently implemented. Certain analysis profiles are dropped for the parameter summarization for any number of reasons. These records are kept but flagged for exclusion in a logical variable (same extent as the WDS).

In future we aim to develop a much more sophisticated solution to this problem allowing for a partition recipe to be given, and for different analysis pathways declared for each partition.

For now, `filter_wds_exclusions` will take the test-case, the name of the flag variable, and the summary-grouping variable (`by`).


```{r excl}
tc <- tc %>%
      filter_wds_exclusions(flg = flag,
                            profile = profile,
                            by = by)
```

## Select summary paramters

The parameter selection interface similar to {dplyr}'s, pass the test-case in first, and then list the parameters of interest (as symbols).

```{r select}
tc <- tc %>%
      select_wds_pars(dplyr::all_of(by), # use all_of() here as this is a string
                      AUCINFP,
                      AUCLAST,
                      AUC0..72,
                      CMAX1,
                      TMAX1,
                      THALF,
                      MRTP)
```

## Use {gtsummary} to produce exclusion and parameter summary and stack the tables for display

For now, the separate elements that make up the final output table need to be created separately and stacked together. In the future this package aims to do this automatically following a recipe the user specifies. Eventually, templates will exist to quickly (re)produce parameter summary tables that follow standard conventions.

Below is an example 'recipe' to make one such table. The data are all found from slots in the test-case, and then the {gtsummary} engine is used to produce the values of interest. The {gtsummary} engine beyond the scope of this walk-through but the I encourage the interested reader to check the package website and vignettes. 

The basic setup is to provide a `data.frame` of parameters to summarize, a grouping variable `by` to split the summaries (over columns, with parameters spanning rows), and then the specific functions and formatting rules for presentation. Here we compute the first table, comprising a single row, of the exclusion statistics, Big N and little n. Afterwards we compute a more complex table with multiple parameters, summary functions, and decimal places. These tables are stacked and then passed into a {gt} object, where we can force interpretation of raw HTML in the cells to render richer characters.

```{r gts}
# First we generate a 1 row table for the Big N little n statistic using the
# exclusions data in the test case

Nn <- tc$exclusions %>%
      dplyr::select(-dplyr::all_of(profile)) %>%
      gtsummary::tbl_summary(by = dplyr::all_of(by),
                             type = list(EXCL ~ 'continuous'),
                             statistic = c(EXCL ~ "{length}, {little_n}"),
                             digits = c(EXCL ~ 0),
                             label = c(EXCL ~"N, n")) %>%
      # remove auto-generated footnote
      gtsummary::modify_footnote(dplyr::everything() ~ NA)

# Next we use the {gtsummary} engine to produce the summaries we want on each
# parameter
gts_tab <- tc$WDS %>%
           gtsummary::tbl_summary(by = dplyr::all_of(by),
                                  digits = list(TMAX1 ~ c(2, 1, 1), # number of 
                                                THALF ~ c(2, 1),    # dig per 
                                                MRTP ~ c(2, 1)),    # stat 
                                  statistic = c(
                                     # param name ~ "{stat}" etc
                                     AUCINFP ~ "{gm_mean} ({gm_cv})",
                                     AUCLAST ~ "{gm_mean} ({gm_cv})",
                                     AUC0..72 ~ "{gm_mean} ({gm_cv})",
                                     CMAX1 ~ "{gm_mean} ({gm_cv})",
                                     TMAX1 ~
                                       "{median} ({lower_range}-{upper_range})",
                                     THALF ~ "{mean} &plusmn {sd}",
                                     MRTP ~ "{mean} &plusmn {sd}"
                                     )) %>%
           # remove auto-generated footnote
           gtsummary::modify_footnote(dplyr::everything() ~ NA)

gtsummary::tbl_stack(list(Nn, gts_tab)) %>%
  gtsummary::as_gt() %>%
  gt::fmt(columns = dplyr::everything(), fns = function(x) x)
```
